% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expdlen.R
\name{growlen}
\alias{growlen}
\title{Expand Data Length}
\usage{
growlen(x, h, direction = "one_side")
}
\arguments{
\item{x}{A time series or a numeric vector.}

\item{h}{An integer. Number of periods for expanding the data.}

\item{direction}{Where to grow the data. Allowed values are
\code{one_side} (default) and \code{both}. The \code{one_side}
grows the data on the end of the series (forecasting). \code{both}
grows on both sides of the series (auto arima backcasting and forecasting).}
}
\value{
A time series or a numeric vector. The length of the returned
value is the original length plus \code{h}.
}
\description{
\code{growlen} exapands the length of a time series or a numeric vector
by running an auto arima regression for forecasting and backcasting.
Extending the sample by inserting forecast can be a simple
remedy for the end point problem.
}
\examples{
GDPC1_grow <- growlen(GDPC1, h = 4)

growlen(GDPC1, h = 8, direction = both)

# EbayesThresh

GDPC1_grow_wavelet <- signal(GDPC1_grow, boundary = "reflection", n.levels = 5, vscale = "level")

gap_wavelet <- 100 * (GDPC1_grow - GDPC1_grow_wavelet) /  GDPC1_grow_wavelet

# Comparing gap_wavelet (end point adjust) with the original GDPC1_GDPPOT

ts.plot(ts.intersect(GDPC1_GDPPOT, gap_wavelet), col = c(1, 2)); abline(h = 0)
legend(1980, 9, legend = c("GDPC1_GDPPOT", "gap_wavelet"), col = c(1, 2), lty = 1)
}
